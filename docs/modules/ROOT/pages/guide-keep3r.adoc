# Setting up a keep3r

This guide will walk you through the process of running a Keeper in the https://keep3r.network/[Keep3r Network] by leveraging Defender xref:relay.adoc[Relay] and xref:autotasks.adoc[Autotasks].

WARNING: The Keep3r Network project is in beta. Use at your own risk.

[[what-is-a-keeper]]
## What is a Keeper?

In the context of the Keep3r Network, Keepers are participants who execute available jobs in exchange for a reward. A contract may register a job to be executed, and once it's available, a registered Keeper can send a transaction to execute it.

[quote, 'https://docs.keep3r.network/#keepers[keep3r.network documentation]']
____
A Keeper is the term used to refer to an external person and/or team that executes a job. This can be as simplistic as calling a transaction, or as complex as requiring extensive off-chain logic. The scope of Keep3r network is not to manage these jobs themselves, but to allow contracts to register as jobs for keepers, and keepers to register themselves as available to perform jobs. It is up to the individual keeper to set up their devops and infrastructure and create their own rules based on what transactions they deem profitable.
____

[[prerequsites]]
## Prerequisites

To get started, you'll need the following:

. *A Defender mainnet account*. Head over to https://defender.openzeppelin.com/[Defender] to sign up for a new account, and then https://openzeppelin.com/apply/[apply for mainnet access] indicating that you are interested in running a Keeper. We'll contact you shortly to activate your account for mainnet access. Note that mainnet accounts are free for now, but will be paid starting end of year.

. *ETH to pay for transactions gas*. Keeper transactions require gas for execution, so make sure to have some ETH available to fund your Relay.

. *An Alchemy, Etherscan, and/or Infura key (optional)*. Running a Keeper requires querying which jobs are available, and https://dashboard.alchemyapi.io/signup?referral=53fcee38-b894-4d5f-bd65-885d241f8d29[Alchemy] (includes referral code), https://infura.io/[Infura], and https://etherscan.io/apis[Etherscan] provide free and paid access to the network for executing these queries. You can do without an API key, but you may get throttled during your Keepers execution. Read more about this https://docs.ethers.io/v5/api-keys/[here].

## Creating a Relayer

The first step will be to create a Defender Relayer to act as your Keeper. This Relayer will be the Ethereum account you will be executing jobs from. 

To create a Relayer, simple head over to the xref:relay.adoc[Relay] section in Defender, and create a new relayer on the Mainnet network.

WARNING: If the option to create the relayer in mainnet is locked, it means your Defender account does not have mainnet access yet. Make sure to https://openzeppelin.com/apply/[apply for mainnet access first] and wait for our response.

## Fund your Relayer

Next step is to send ETH to your Relayer, so it has funds to execute the jobs. Copy the Ethereum address of your new Relayer, and use your favorite wallet to send ETH to it. You can send whatever amount you want, but you want at least around 0.2 ETH to be able to send a handful of transactions before running out.

NOTE: Defender will send you an email when your Relay's funds drop below 0.1 ETH to remind you to refill it.

## Create an Autotask

Now that you have your Relay ready to send transactions, let's set up the Defender Autotask that will instruct the Relay to send them. An Autotask is a snippet of code that runs at regular intervals, in this case, we'll use it to automate the process of bonding, activating, searching for jobs, and executing them.

Create a new Autotask in the xref:autotasks.adoc[Autotasks] section of Defender, choosing to run every few minutes, and connecting it to the Relay you had created previously.

As for the code, paste the following snippet, replacing the `0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA` value with your Relay address in the first line, and replacing `NONE` with the Alchemy, Infura, or Etherscan tokens respectively if you have any.

[source,jsx]
----
// Replace with the Relay address
const from = '0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';

// Insert your Infura, Etherscan, or Alchemy tokens, if you have them
const alchemyToken = 'NONE';
const infuraToken = 'NONE';
const etherscanToken = 'NONE';

// Keeper registry address
const registryAddr = '0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44';

// Workable address
const workableAddr = '0xe7F4ab593aeC81EcA754Da1B3B7cE0C42a13Ec0C';

// We bond 0 KPR tokens for registration
const collateralAddr = '0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44';
const collateralAmount = '0x00';

const registryAbi = [{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"keeper","type":"address"},{"indexed":false,"internalType":"uint256","name":"block","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"activated","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"bond","type":"uint256"}],"name":"KeeperBonded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"keeper","type":"address"},{"indexed":false,"internalType":"uint256","name":"block","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"active","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"bond","type":"uint256"}],"name":"KeeperBonding","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"keeper","type":"address"},{"indexed":false,"internalType":"uint256","name":"block","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"deactive","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"bond","type":"uint256"}],"name":"KeeperUnbonding","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"keeper","type":"address"},{"indexed":false,"internalType":"uint256","name":"block","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"deactivated","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"bond","type":"uint256"}],"name":"KeeperUnbound","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"credit","type":"address"},{"indexed":true,"internalType":"address","name":"job","type":"address"},{"indexed":true,"internalType":"address","name":"keeper","type":"address"},{"indexed":false,"internalType":"uint256","name":"block","type":"uint256"}],"name":"KeeperWorked","type":"event"},{"inputs":[],"name":"BOND","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"LIQUIDITYBOND","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"UNBOND","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"bonding","type":"address"}],"name":"activate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"blacklist","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"bonding","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"bond","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"bondings","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"bonds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"firstSeen","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getKeepers","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"keeper","type":"address"}],"name":"isKeeper","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"keeperList","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"keepers","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"lastJob","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"partialUnbonding","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"pendingbonds","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalBonded","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"bonding","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"unbond","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"unbondings","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"votes","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"bonding","type":"address"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}];
const workableAbi = [{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"worker","type":"address"}],"name":"Worked","type":"event"},{"inputs":[],"name":"requestWork","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"work","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"workable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}];

const { ethers } = require("ethers");
const { DefenderRelaySigner } = require('defender-relay-client/lib/ethers');

async function workIfNeeded(contract) {
  if (await contract.workable()) {
    const tx = await contract.work();
    console.log(`Worked ${contract.address}:`, tx.hash);
  } else {
    console.log(`No work needed for ${contract.address}`);
  }
}

function getProvider() {
  return ethers.getDefaultProvider('homestead', {
    etherscan: etherscanToken === 'NONE' ? null : etherscanToken,
    infura: infuraToken === 'NONE' ? null : infuraToken,
    alchemy: alchemyToken === 'NONE' ? null : alchemyToken,
  })
}

// Entrypoint for the Autotask
exports.handler = async function(credentials) {
  const provider = getProvider();
  const signer = new DefenderRelaySigner(credentials, provider, { speed: 'fastest', from });
  const registry = new ethers.Contract(registryAddr, registryAbi, signer);
  const contract = new ethers.Contract(workableAddr, workableAbi, signer);

  // Work if is a registered keeper
  if (await registry.isKeeper(from)) {
    return await workIfNeeded(contract);
  }

  // Otherwise run through bonding and activation process
  const bonding = await registry.bondings(from, collateralAddr).then(b => b.toNumber());
  if (bonding === 0) {
    const tx = await registry.bond(collateralAddr, collateralAmount);
    console.log(`Bonded relayer: ${tx.hash}`);
  } else if (bonding < Date.now() / 1000) {
    const tx = await registry.activate(collateralAddr);
    console.log(`Activated relayer: ${tx.hash}`);
    await workIfNeeded(contract);
  } else {
    console.log(`Waiting ${bonding - parseInt(Date.now() / 1000)} seconds until activation is available`);
  }
}

// To run locally (this code will not be executed in Autotasks)
if (require.main === module) {
  const { API_KEY: apiKey, API_SECRET: apiSecret } = process.env;
  exports.handler({ apiKey, apiSecret })
    .then(() => process.exit(0))
    .catch(error => { console.error(error); process.exit(1); });
}
----

## Wait for Keeper activation

The script above will take care of *bonding* your Relay to the keep3r network using zero KPR tokens as collateral. After bonding, there is a three-day delay enforced by the network before you can start using your Keeper. Once that time has passed, the script above will take care of *activating* your Relay as a Keeper.

Once your Keeper is activated, it will query the `YearnV1EarnKeep3r` job to see if there is work to do by calling `workable`, and if so, will send a transaction to execute the `work`. You can check out your Autotask logs to see what your Keeper has done on each run.

WARNING: Keep in mind that sending the transaction does not automatically mean you will get rewarded for it: other Keepers may also be monitoring the job for work, and if their transaction gets mined before yours, you will not get the reward!

## Coming soon...

We are working on additional features in Defender to make this process easier. This involves being able to send Relayer transactions from the Defender site, so you can bond the Relay with the collateral you want and easily transfer your KPR rewards out of the Relay to your wallet without having to write code for it; adding a custom Defender provider, so you don't need to request an Alchemy, Infura, or Etherscan token yourself; creating a registry of Autotask scripts, so you don't need to copy-paste code from this document; showing Keeper information in the Relayer page, so you know whether your Relayer has been activated and the rewards earned so far; and more. We will be updating this document as we progress with these features. Stay tuned!
